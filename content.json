{"meta":{"title":"lulula","subtitle":null,"description":null,"author":"lulula","url":"http://yoursite.com"},"pages":[{"title":"All categories","date":"2014-12-22T04:39:04.000Z","updated":"2018-02-10T12:34:09.604Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2018-02-10T10:55:42.000Z","updated":"2018-02-10T10:55:42.422Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"live","date":"2018-02-10T10:59:39.000Z","updated":"2018-02-10T10:59:39.434Z","comments":true,"path":"live/index.html","permalink":"http://yoursite.com/live/index.html","excerpt":"","text":""},{"title":"All tags","date":"2014-12-22T04:39:04.000Z","updated":"2018-02-10T12:31:43.710Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript Array对象属性方法总结","slug":"JavaScript-Array对象属性方法总结","date":"2018-04-09T11:43:27.000Z","updated":"2018-04-09T11:44:48.234Z","comments":true,"path":"2018/04/09/JavaScript-Array对象属性方法总结/","link":"","permalink":"http://yoursite.com/2018/04/09/JavaScript-Array对象属性方法总结/","excerpt":"","text":"concat() array1.concat(array2,array3,...,arrayX) 方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本（新数组）。 every() array.every(function(currentValue,index,arr), thisValue) every() 方法用于检测数组 所有元素 是否都符合指定条件（通过函数提供）。every() 方法使用指定函数检测数组中的所有元素：如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。如果所有元素都满足条件，则返回 true。(返回值为Boolean) fill() array.fill(value, start, end) fill() 方法用于将一个固定值替换数组的元素。（改变原来的数组）注意 : IE 11 及更早版本不支持 fill() 方法。 filter() array.filter(function(currentValue,index,arr), thisValue) filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。如果没有符合条件的元素则返回空数组。 find() array.find(function(currentValue, index, arr),thisValue) 返回传入一个测试条件（函数）符合条件的数组第一个元素。当数组中的元素在测试条件时返回 true 时, find() 返回符合条件的元素，之后的值不会再调用执行函数。返回符合测试条件的第一个数组 元素索引值 ，如果没有符合条件的则返回 undefined findIndex() array.findIndex(function(currentValue, index, arr), thisValue) 返回传入一个测试条件（函数）符合条件的数组第一个元素位置。当数组中的元素在测试条件时返回 true 时, findIndex() 返回符合条件的元素的索引位置，之后的值不会再调用执行函数。如果没有符合条件的元素返回 -1 总结every方法需要所有的元素都满足，返回布尔值，filter方法返回所有满足条件的元素，返回一个新数组，find方法返回符合测试条件的第一个元素，没有返回undefined，而findIndex方法的区别在于没有符合条件是返回的是-1","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"offsetLeft,Left,clientLeft详解","slug":"offsetLeft-Left-clientLeft详解","date":"2018-03-15T14:29:30.000Z","updated":"2018-03-15T14:31:45.248Z","comments":true,"path":"2018/03/15/offsetLeft-Left-clientLeft详解/","link":"","permalink":"http://yoursite.com/2018/03/15/offsetLeft-Left-clientLeft详解/","excerpt":"","text":"背景最近写了一个滑动条，发现自己的对offsetLeft,Left,clientLeft这几个的概念还不是很清楚，于是决定细细研究下。 分类 client部分 clientHeight:内容可视区域的高度，也就是说页面浏览器中可以看到内容的这个区域的高度(不含边框，也不包含滚动条等边线，会随窗口的显示大小改变) clientLeft,clientTop: 这两个返回的是元素周围边框的厚度（border）,如果不指定一个边框或者不定位改元素,他的值就是0. offset部分计算时都包括此对象的border，paddingoffsetLeft：获取对象左侧与定位父级之间的距离offsetTop：获取对象上侧与定位父级之间的距离PS：获取对象到父级的距离取决于最近的定位父级offsetWidth：获取元素自身的宽度（包含边框）offsetHeight：获取元素自身的高度（包含边框）注：与style.top 不同，offsetLeft只可读，不可以对其进行赋值。offsetTop 返回的是数字，而 style.top 返回的是字符串，除了数字外还带有单位：px。与style.width属性的区别在于:如对象的宽度设定值为百分比宽度,则无论页面变大还是变小,style.width都返回此百分比,而offsetWidth则返回在不同页面中对象的宽度值而不是百分比值 scroll部分scrollLeft：设置或获取当前左滚的距离，即左卷的距离；scrollTop：设置或获取当前上滚的距离，即上卷的距离；scrollHeight：获取对象可滚动的总高度；scrollWidth：获取对象可滚动的总宽度；scrollHeight = content + padding；（即border之内的内容）","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"jq实现预览查看插件","slug":"jq实现预览查看插件","date":"2018-03-08T14:28:24.000Z","updated":"2018-03-08T14:30:00.656Z","comments":true,"path":"2018/03/08/jq实现预览查看插件/","link":"","permalink":"http://yoursite.com/2018/03/08/jq实现预览查看插件/","excerpt":"","text":"功能鼠标移到缩略图上会显示该图的大图，并且大图跟随鼠标移动；或是移动到提示文字上，也可以显示图片。并且含有方向判别功能，具体来说就是如果缩略图在页面的左半部分，则大图显示在鼠标的右侧，如果缩略图在页面的右半部分，则预览的大图在鼠标的左侧显示。 思路分析 html结构1&lt;a href=&quot;xx.jpg&quot;&gt;缩略图&lt;/a&gt; 当鼠标覆盖到&lt;a&gt;&lt;/a&gt;时获取预览图地址预览图结构1&lt;div id=&apos;preview&apos;&gt;&lt;div&gt;&lt;img src=&apos;&quot;+$(this).attr(&apos;href&apos;)+&quot;&apos; /&gt;&lt;p&gt;&quot;+$(this).attr(&apos;title&apos;)+&quot;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt; 添加到body，使用绝对定位 插件开发 因为想试下插件开发的模式，所以这样写了 123$.fn.preview=function()&#123; ......&#125; jQuery.fn = jQuery.prototype.对prototype每一个jq对象都可以用 源码123456789101112131415161718192021222324252627&lt;style&gt;.imgbox&#123; margin-top: 150px; text-align: center;&#125;.imgbox img &#123; display: inline-block; width: 250px; height: 144px;&#125;&lt;/style&gt;&lt;script&gt; $(function()&#123; $(&quot;a.preview&quot;).preview(); //页面加载完后执行 &#125;);&lt;/script&gt;&lt;body&gt; &lt;div class=&quot;page&quot;&gt; &lt;div class=&quot;imgbox&quot;&gt; &lt;a class=&quot;preview&quot; href=&quot;./img/cool_couple_dark.jpg&quot; title=&quot;cool cuple&quot;&gt;&lt;img src=&quot;./img/cool_couple_dark.jpg&quot; alt=&quot;cool couple&quot;&gt;&lt;/a&gt; &lt;a class=&quot;preview&quot; href=&quot;./img/cool_couple_dark.jpg&quot; title=&quot;cool cuple&quot;&gt;&lt;img src=&quot;./img/cool_couple_dark.jpg&quot; alt=&quot;cool couple&quot;&gt;&lt;/a&gt; &lt;a class=&quot;preview&quot; href=&quot;./img/cool_couple_dark.jpg&quot; title=&quot;cool cuple&quot;&gt;&lt;img src=&quot;./img/cool_couple_dark.jpg&quot; alt=&quot;cool couple&quot;&gt;&lt;/a&gt; &lt;a class=&quot;preview&quot; href=&quot;./img/cool_couple_dark.jpg&quot; title=&quot;cool cuple&quot;&gt;&lt;img src=&quot;./img/cool_couple_dark.jpg&quot; alt=&quot;cool couple&quot;&gt;&lt;/a&gt; &lt;a class=&quot;preview&quot; href=&quot;./img/cool_couple_dark.jpg&quot; title=&quot;cool cuple&quot;&gt;查看&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; jquery-imgpreview.js1234567891011121314151617181920212223242526272829303132333435363738(function($)&#123; $.fn.preview=function () &#123; $(this).each(function () &#123; var xOffset = 10; var yOffset = 20; var screenW =$(window).width(); $(this).hover(function (e) &#123; var imgsrc= $(this).attr(&quot;href&quot;) if(/.png$|.gif$|.jpg$|.bmp$/.test(imgsrc))&#123; $(&apos;body&apos;).append(&quot;&lt;div id=&apos;preview&apos;&gt;&lt;div&gt;&lt;img src=&apos;&quot;+imgsrc+&quot;&apos; /&gt;&lt;p&gt;&quot;+$(this).attr(&apos;title&apos;)+&quot;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&quot;); $(&apos;#preview&apos;).css(&#123; width:&apos;325px&apos;, position:&apos;absolute&apos;, left:e.pageX+xOffset+&apos;px&apos;, top:e.pageY+yOffset+&apos;px&apos;, backgroundColor:&quot;#eeeeee&quot;, padding:&quot;4px&quot;, border:&quot;1px solid #f3f3f3&quot;, zIndex:1000 &#125;), $(&apos;#preview &gt; div &gt; img&apos;).css(&#123; width:&apos;100%&apos;, height:&apos;100%&apos; &#125;) &#125; &#125;,function () &#123; $(&apos;#preview&apos;).remove(); &#125;).mousemove(function(e)&#123; $(&quot;#preview&quot;).css(&quot;top&quot;,e.pageY+ &quot;px&quot;) if(e.pageX &lt; screenW/2)&#123; $(&quot;#preview&quot;).css(&quot;left&quot;,(e.pageX + xOffset) + &quot;px&quot;).css(&quot;right&quot;,&quot;auto&quot;); &#125;else&#123; $(&quot;#preview&quot;).css(&quot;right&quot;,(screenW - e.pageX + xOffset) + &quot;px&quot;).css(&quot;left&quot;,&quot;auto&quot;); &#125; &#125;); &#125;) &#125;&#125;)(jQuery)","categories":[],"tags":[{"name":"jquery","slug":"jquery","permalink":"http://yoursite.com/tags/jquery/"}]},{"title":"JavaScript移除绑定在元素上的匿名事件处理函数","slug":"JavaScript移除绑定在元素上的匿名事件处理函数","date":"2018-03-06T13:08:30.000Z","updated":"2018-03-06T13:13:13.926Z","comments":true,"path":"2018/03/06/JavaScript移除绑定在元素上的匿名事件处理函数/","link":"","permalink":"http://yoursite.com/2018/03/06/JavaScript移除绑定在元素上的匿名事件处理函数/","excerpt":"","text":"#问题#用addEventListener()和attachEvent()给一个DOM元素绑定事件处理程序时，如果传入一个匿名函数，那么用相应的removeEventListener()和detachEvent()是无法将这个匿名的处理程序解除绑定的。所以我们用的时候应该传入一个函数表达式。 那么，如果我就是想使用匿名函数进行绑定和解绑，怎么解决？ #思路#这两个函数都不接受匿名函数进行解绑，那么就不能依靠他们来管理事件了，所以自定义一个对象来事件。事件处理程序的本质就是，当一个事件在一个对象上发生时，执行监听这个事件的函数。 一个DOM元素可能被绑定多个事件类型的处理程序。比如click的时候颜色改变，mouseover的时候变大。 一个事件类型可能绑定多个事件处理程序。比如mouseover的时候又变色又变大。 所以，这个事件对象应该有一个属性用来存储这个DOM元素上绑定的所有事件处理程序，还应该有两个方法，一个用来添加，一个用来删除。 123456789&#123; handlers:&#123; type1:[handler1,handler2], type2:[handler1,handler2], ...//其他事件类型和对应的事件处理函数 &#125;, on:function()&#123;&#125;, off:function()&#123;&#125;&#125; 当一个事件发生时，就调用这个对象里面对应的事件类型的数组里面的所有函数。 所以绑定事件就是往对应的数组里面添加函数，解除绑定事件就是把这个函数从这个数组里面删掉。 那么怎么保证操作的是那个正确的DOM元素呢？ 显然，每个DOM元素都应该需要一个这样的对象，用于管理自己的事件处理程序。使这个事件管理对象成为dom元素的属性就保证了操作的是正确的dom元素 #实现#每个DOM元素都需要这样一个对象，而且每个对象中的on()和off()方法都是相同的，所以需要一个构造函数，把这两个方法放到他的原型对象中去。 1234567891011121314151617181920function EventManage() &#123; this.handlers = &#123;&#125;&#125;EventManage.prototype = &#123; on: function (type, handler) &#123; if (!this.handlers[type]) &#123; this.handlers[type] = [handler] return true //避免添加多个事件 &#125; else &#123; this.handlers[type].push(handler) &#125; &#125;, off: function (type, handler) &#123; for (var i = 0; i &lt; this.handlers[type].length; i++) &#123; if (this.handlers[type][i].toString() == handler.toString()) &#123; this.handlers[type].splice(i, 1); &#125; &#125; &#125;&#125; 每个对象有了这两个方法，就可以自行添加和移除事件处理程序了，但是，监听事件，还是要靠JavaScript提供的方法，所以借用addEventListner()和attachEvent()来监听事件： 1234567891011121314151617181920212223var EventUtil = &#123;&#125;;EventUtil.on = function (ele, type, handler) &#123; if (!ele.event) &#123; ele.event = new EventManage(); console.log(ele.event.handlers) &#125; var isNewType = ele.event.on(type, handler); var fire = function () &#123; for (var i = 0; i &lt; ele.event.handlers[type].length; i++) &#123; ele.event.handlers[type][i](); &#125; &#125; if (isNewType) &#123; if (ele.addEventListener) &#123; ele.addEventListener(type, fire, false); &#125; else &#123; ele.attachEvent(&quot;on&quot; + type, fire) &#125; &#125;&#125;EventUtil.off = function (ele, type, handler) &#123; ele.event.off(type, handler);&#125; 这里要注意一个问题，每次使用EventUtil.on()时都会重新定义一个fire函数，addEventListener()就会给相同的事件类型添加多个相同的事件处理程序，所以需要判断一下这个事件类型是不是新增的，如果是的话再用addEventListener()来监听这个事件类型。 #使用示例：#1234567891011var btn=document.getElementById(&quot;btn&quot;);EventUtil.on(btn,&quot;click&quot;,function()&#123;console.log(&quot;11&quot;);&#125;);EventUtil.on(btn,&quot;click&quot;,function()&#123;console.log(&quot;22&quot;);&#125;);EventUtil.off(btn,&quot;click&quot;,function()&#123;console.log(&quot;11&quot;);&#125;);","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"gulp初步学习和使用","slug":"gulp初步学习和使用","date":"2018-03-04T08:13:19.000Z","updated":"2018-03-04T08:50:22.069Z","comments":true,"path":"2018/03/04/gulp初步学习和使用/","link":"","permalink":"http://yoursite.com/2018/03/04/gulp初步学习和使用/","excerpt":"","text":"简介简单来说，它所实现的效果就是将所有的js文件整合到一个js文件里面，并且压缩成一行。在node环境下运行,具体查看 官网 安装第一步：我们打开git的命令行工具，去命令行npm install -g gulp（安装全局gulp）。 安装一下全局的gulp 等待几分钟之后就下载好了，然后输入gulp –v来查看一下gulp是否存在以及版本是多少。 第二步：在我们项目的文件夹中（根目录下）打开命令行。输入命令npm install –save-dev gulp（下载本地gulp），等待下载完毕会出现一个本地的文件夹node_modules文件夹。这就说明我们本地的gulp已经下载好了。 第三步：就在上图这个根目录中，我们新建一个js，名字叫gulpfile.js 这里面是用来写我们gulp运行的一些行为，比如合并，压缩，重命名啊，等等。先配置，到后面一看就明白了 到了第四步我们要了解我们需要做什么： 在项目的根目录中的命令行中，输入我们要用到的东西，这些都是局部的： 如果想要压缩js代码：$ npm install –save-devgulp-uglify 如果想要压缩css代码：$ npm install–save-dev gulp-minify-css 如果想要删除文件夹和文件的命令：$ npm install–save-dev gulp del 如果想要less转换为css插件：$ npm install–save-dev gulp-less 如果想要合并文件：$ npm install –save-devgulp-concat 如果想要给文件重新命名：$ npm install –save-devgulp-rename 第四步：按需求下载好自己所需要的局部组件，然后下一步就是要去gulpfile.js里面配置我们gulp运行时候的行为了 首先引入刚刚下载好的组件：1234567891011//引入gulpvar gulp = require(&apos;gulp&apos;);//引入组件（这里面有：重命名，压缩js的组件，合并js的组件）var concat = require(&apos;gulp-concat&apos;);var uglify = require(&apos;gulp-uglify&apos;);var rename = require(&apos;gulp-rename&apos;); 组件引入之后，我们开始写我们gulp的行为了，也就是我们运行gulp的时候他需要怎么做。 //举个例子：这是把js压缩并且合并的一个行为 其中：task（任务）：每一个gulp的命令都是一个任务。 src（引入）：引入需要构建的文件路径。 dest（输入）：输出文件的路径。 watch（监听）：监听文件的变化，可以自动执行任务。123456789101112131415161718192021222324252627//我给这个行为起了一个名字为” scripts”，然后紧接着一个回掉函数记录他的行为gulp.task(&apos;scripts&apos;, function() &#123;//引入js文件夹下面的所有.js格式的文件，*代表全部，当然也可以针对到某一个js文件。gulp.src(&apos;./js/*.js&apos;)//concat就是我们下载好，然后还引进来的那个组件，合并他们所有的js文件合并玩了名字叫做all.js.pipe(concat(&apos;all.js&apos;))//合并完之后我将他输出到根目录下的一个新的文件夹“dist“里面.pipe(gulp.dest(&apos;./dist&apos;))//虽然所有js文件合并到了all.js里面，但是他们现在格式还是“生前“的样子，我需要将它们变为一行！这时候就用到了一个重命名：rename我给all.js起了一个名字叫做all.min.js，紧接着用到了引入的js压缩组件uglify()，然后那么多行的js文件就变为了一两行的.pipe(rename(&apos;all.min.js&apos;)).pipe(uglify())//处理完之后我也将他输出到根目录下的文件夹“dist“里面.pipe(gulp.dest(&apos;./dist&apos;));&#125;); 这时候在gulpfile.js文件里面相当于记录了两种行为了，一种是引入，一种是操作不要以为这时候就大功告成了，还有最重要的一部：我们需要继续写一个默认的任务123456789101112131415//默认任务default，这个名字是必不可少的gulp.task(&apos;default&apos;,function()&#123;//run一下（默认执行的是我写的名字为&apos;scripts&apos;进行js代码压缩的行为）gulp.run(&apos;scripts&apos;);//监听文件变化（如果js文件有变化，就会执行下面的行为）gulp.watch(&apos;./js/*.js&apos;, function()&#123;gulp.run(&apos;lint&apos;, &apos;sass&apos;, &apos;scripts&apos;);&#125;); 有人要问，如果不写默认行为可以不，回答是当然不可以，如果不写默认行为会报错的 最后一步：运行 既然都已经配置好了，我们就来运行一下吧，回到项目的根目录中，我们打开git的命令行，输入gulp并且回车，很好，出现这些时间表示我们已经成功了。然后我们会看到根目录自己出现了一个名字叫做dist的文件夹，小心翼翼的打开里面，惊喜的发现了all.js以及all.min.js两个文件静静的躺在里面。 如果运行：gulp是执行gulpfile.js里面所有的任务。如果此时有一个压缩css的任务，有一个压缩js的任务，分别叫做script和css 我们只想压缩一下js，那么就执行gulp+任务名称也就是：$ gulp script完成！！！！！只会压缩js，不回去动css的代码。 作者：传奇狗链接：https://www.jianshu.com/p/bedb9ffcfba1來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[],"tags":[{"name":"javascrip,node","slug":"javascrip-node","permalink":"http://yoursite.com/tags/javascrip-node/"}]},{"title":"前端优化法则","slug":"前端优化法则","date":"2018-02-11T10:56:53.000Z","updated":"2018-02-11T12:58:10.480Z","comments":true,"path":"2018/02/11/前端优化法则/","link":"","permalink":"http://yoursite.com/2018/02/11/前端优化法则/","excerpt":"","text":"共35条分类 内容 减少HTTP请求 减少DNS查询 避免重定向 Ajax缓存化 后载入组件 预先载入组件 减少DOM元素数量 跨域分离组件 最少化iframe 避免404错误 服务端 使用CDN（内容分布网络） 增加过期时间或者可控制缓存的请求头 使用Gzip组件 配置ETags（实体标签） 提前刷新缓冲区 Ajax请求使用Get方法 避免空的图片src Cookie 减少Cookie大小 为组件使用无Cookie域 CSS 将样式放在顶部 避免使用CSS表达式 选择而不要@import 避免过滤器 JavaScript 将JS放在底部 使用外部的JS和CSS 压缩JS和CSS 去掉重复的脚本 最小化Dom读取 开发灵活的事件处理器 图片 优化图片 优化CSS Sprites（CSS精灵） 在HTML中不要缩放图片 制作小的和可缓存的favicon.ico 移动 组件维持在25kb以下 将组件放入复合的文档中 转自[https://huangyijie.com/2016/02/29/rules-of-front-end-optimization/]","categories":[{"name":"优化","slug":"优化","permalink":"http://yoursite.com/categories/优化/"}],"tags":[{"name":"javascript,css,前端","slug":"javascript-css-前端","permalink":"http://yoursite.com/tags/javascript-css-前端/"}]},{"title":"css 居中总结","slug":"css居中总结","date":"2018-02-10T08:36:31.000Z","updated":"2018-02-10T10:04:03.805Z","comments":true,"path":"2018/02/10/css居中总结/","link":"","permalink":"http://yoursite.com/2018/02/10/css居中总结/","excerpt":"","text":"水平居中 内联元素（inline、inline-*） 此类元素需要水平居中，则父级元素必须是块级元素(block level)，且父级元素上需要这样设置样式：123.parent &#123; text-align: center;&#125; 块级元素 块级元素水平居中，需要设置margin-left和margin-right为auto，且需要显示设置宽度，不然就占满整行，就无所谓水平居中了。1234.block &#123; width: 300px; margin: 0 auto;&#125; 同一行多个块级元素 如果是在同一行里需要居中多个块级元素，可以尝试下面的两种方法： 12345678910111213141516/* 方法一 */.parent &#123; text-align: center;&#125;.parent div &#123; display: inline-block;&#125;/* 方法二 */.parent &#123; display: -webkit-box; display: -ms-flexbox; display: flex; -webkit-box-pack: center; -ms-flex-pack: center; justify-content: center;&#125; 垂直居中垂直居中在CSS中比较不好处理。 单行文本 通过设置上下内间距一致达到垂直居中的效果： 1234.single-line &#123; padding-top: 10px; padding-bottom: 10px;&#125; 通过设置height和line-height一致达到垂直居中：1234.single-line &#123; height: 100px; line-height: 100px;&#125; 多行文本 通过使用表格来垂直居中，但是这种方法显得很累赘：1234567&lt;table&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;通过表格使得多行文本自动垂直居中通过表格使得多行文本自动垂直居中通过表格使得多行文本自动垂直居中&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 通过设置vertical-align属性和将元素设置为table-cell，且父元素要设置为table元素，这个和上面那种原理其实是一样的：1234567.parent &#123; display: table;&#125;.parent div &#123; display: table-cell; vertical-align: middle;&#125; 通过伸缩盒来垂直居中：1234567.flex-vertically &#123; -webkit-align-items: center; -ms-flex-align: center; align-items: center; display: -webkit-flex; display: flex;&#125; 块级元素垂直居中 知道块元素的高度，那么使用绝对定位和负的margin即可实现垂直居中：123456789.parent &#123; position: relative;&#125;.parent div &#123; position: absolute; top: 50%; height: 50px; margin-top: -25px;&#125; 块级元素高度是可变的，这个时候就需要用transform的Y轴平移来实现了：12345678.parent &#123; position: relative;&#125;.parent div &#123; position: absolute; top: 50%; transform: translateY(-50%);&#125; 也可以使用flexbox:12345.parent &#123; display: flexbox; justify-content: center; flex-direction: column;&#125; 如果对于块级元素高度不是固定的，且不由内容决定，那么还可以这么设置： 12345678.parent &#123; position: relative;&#125;.parent div &#123; position: absolute; top: 30%; bottom: 30%; &#125; 水平垂直居中水平垂直居中就是把上面介绍的方法相结合就可以了。 知道宽高的盒子 123456789101112.parent &#123; position: realtive;&#125;.parent div &#123; width: 300px; height: 300px; posotion: absoltue; left: 50%; top: 50%; margin-left: -150px; margin-top: -150px;&#125; 不知道宽高的盒子 123456789.parent &#123; position: realtive;&#125;.parent div &#123; posotion: absoltue; left: 50%; top: 50%; transform: translate(-50%, -50%); &#125; 使用flexbox 12345.parent &#123; display: flex; justify-content: center; align-items: center;&#125; 以上转自[http://bubuzou.com/2017/04/css-center-skill/] 补充 垂直水平居中1234567891011121314151617&lt;div class=&quot;a&quot;&gt; &lt;div class=&quot;b&quot;&gt; &lt;div class=&quot;c&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; .a&#123; display: table; &#125; .b&#123; display: table-cell; vertical-align: middle; &#125; .c&#123; width: 30px; margin: 0 auto; &#125;","categories":[{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"js刷题记录","slug":"js刷题记录","date":"2018-02-10T08:36:31.000Z","updated":"2018-02-10T11:26:28.232Z","comments":true,"path":"2018/02/10/js刷题记录/","link":"","permalink":"http://yoursite.com/2018/02/10/js刷题记录/","excerpt":"","text":"3、一个数组 par 中存放有多个人员的信息，每个人员的信息由年龄 age 和姓名 name 组成，如{age: 2, name: ‘xx’}。请写一段 JS 程序，对这个数组按年龄从小到大进行排序。 优化： 12345function parSort(par) &#123; return par.sort(function(arr1, arr2) &#123; return arr1.age &gt; arr2.age ? -1 : 1; &#125;);&#125; 4、有字符串 var = ‘abc345efgabcab’，请写出 3 条 JS 语句分别实现如下 3 个功能：1）去掉字符串中的a、b、c 字符，形成结果：’345efg’2）将字符串中的数字用中括号括起来，形成结果：’abc3[5]efgabcab’3）将字符串中的每个数字的值分别乘以 2，形成结果：’abc6810efgabcab’ 我的： var str= &apos;abc345efgabcab&apos;; var arrStr=str.split(&apos;&apos;); var result= arrStr.filter(function(s){ return s==&apos;a&apos; || s==&apos;b&apos; || s==&apos;c&apos;?&apos;&apos;:s }).join(&apos;&apos;) var result=[]; arrStr.forEach(function(s){ var num=s; if(Number(s)==s){ num=&apos;[&apos;+num+&apos;]&apos; } result.push(num) }) result.join(&apos;&apos;); 这个时候对正则表达式还不了解，看了别人的发现用正则表达式会非常简洁 优化： // 1) str.replace(/([a-c])/g, &apos;&apos;); // 2) str.replace(/(\\d)/g, &apos;[$1]&apos;); // 3) str.replace(/(\\d)/g, function(num) {return num*2;}); 5、请写一段 JS 程序类，定义一个列表类List，该类包含两个成员：属性 length（表示列表中的元素个数）和方法 add （像列表中添加元素），其中要求构造函数和 add 方法的参数为动态参数。 我的： function List() { this.data = []; for(var i in arguments){ this.data.push(arguments[i]) } this.length = this.data.length; this.add = function () { for(var i in arguments){ this.data.push(arguments[i]) this.length++; } } } var newlist = new List(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;); //newlist.add(&apos;a&apos;, &apos;b&apos;) arguments对象不是一个 Array 。它类似于Array，但除了length属性和索引元素之外没有任何Array属性 6、请问这个 JS 程序有什么问题？应该如何优化？ function setStyle(element) { element.style.fontWeight = &quot;bold&quot;; element.style.textDecoration = &quot;none&quot;; element.style.color = &quot;#000000&quot;; } 优化： function setStyle(element) { if (!element.style) { return; } var eleStyle = element.style; eleStyle.fontWeight = &quot;bold&quot;; eleStyle.textDecoration = &quot;none&quot;; eleStyle.color = &quot;#000000&quot;; } 7、请写出一下正则表达式：1）匹配一个全部是数字的字符串2）提取一个 url 所使用的协议类型如 http、ftp 和 host 名称 我的： var patt1= /^\\d+$/ var patt2 = /^(\\w+):\\/\\/w*\\.?(\\w+)\\.\\w+\\/.*\\.(\\w+)/; 8、请使用闭包的方式，写一段 JS 程序实现如下功能：函数每调用一次则该函数的返回值加 1。 我的： function creatSumFun(){ var s=0; return function(){ return ++s; } } var sumFun=creatSumFun(); sumFun(); 9、请写出下面 JS 程序中几个 document.write 的结果： function Parent() { this.a = 1; this.b = [1, 2, this.a]; this.c = {demo: 5}; this.show = function() { document.write(this.a + &apos; &apos; + this.c.demo + &apos;:&apos; + this.b + &apos;&lt;br/&gt;&apos;) } } function Child() { this.a = 2; this.change = function() { this.b.push(this.a); this.a = this.b.length; this.c.demo = this.a++; } } Child.prototype = new Parent(); var parent = new Parent(); var child1 = new Child(); var child2 = new Child(); child1.a = 11; child2.a = 12; parent.show(); child1.show(); child2.show(); child1.change(); child2.change(); parent.show(); child1.show(); child2.show(); 我的：无 真的是基础不行，看了好久发现是js的继承，继续努力！11、请用 js 程序实现二分算法。 function midSearch(arr , target){ var low=0; var heigh=arr.length-1; while (low&lt;=heigh) { var mid=parseInt(low+(heigh-low)/2); if(target&gt;arr[mid]){ low=mid+1 } if(target&lt;arr[mid]){ heigh=mid-1 } if(target==arr[mid]){ return mid} } return low } 12、有这样一个 URL：http://vip.qq.com/a.php?a=1&amp;b...，请写一段 JS 程序提取 URL 中的各个参数（参数名和参数个数不确定），将其按 key-value 形式返回到一个 json 结构中，如{a:’1’,b:’2’,c:’’,d:’xxx’,e:undefined}。 function getQueJson(url) { var url=url.split(&apos;?&apos;); var part = /\\w+(=)?(\\w+)*/g; var str = url.match(part); var json = {}; for (var i = 0; i &lt; str.length; i++) { var s = str[i].split(&apos;=&apos;); json[s[0]] = s[1]==&apos;&apos;?undefined:s[1]; } return json }","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]}]}